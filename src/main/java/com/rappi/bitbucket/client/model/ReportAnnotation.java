/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * OpenAPI spec version: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.rappi.bitbucket.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import org.threeten.bp.OffsetDateTime;
/**
 * ReportAnnotation
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-11-12T14:05:09.453-06:00[America/Mexico_City]")
public class ReportAnnotation extends Object {
  @JsonProperty("external_id")
  private String externalId = null;

  @JsonProperty("uuid")
  private String uuid = null;

  /**
   * The type of the report.
   */
  public enum AnnotationTypeEnum {
    VULNERABILITY("VULNERABILITY"),
    CODE_SMELL("CODE_SMELL"),
    BUG("BUG");

    private String value;

    AnnotationTypeEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static AnnotationTypeEnum fromValue(String text) {
      for (AnnotationTypeEnum b : AnnotationTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("annotation_type")
  private AnnotationTypeEnum annotationType = null;

  @JsonProperty("path")
  private String path = null;

  @JsonProperty("line")
  private Integer line = null;

  @JsonProperty("summary")
  private String summary = null;

  @JsonProperty("details")
  private String details = null;

  /**
   * The state of the report. May be set to PENDING and later updated.
   */
  public enum ResultEnum {
    PASSED("PASSED"),
    FAILED("FAILED"),
    SKIPPED("SKIPPED"),
    IGNORED("IGNORED");

    private String value;

    ResultEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ResultEnum fromValue(String text) {
      for (ResultEnum b : ResultEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("result")
  private ResultEnum result = null;

  /**
   * The severity of the annotation.
   */
  public enum SeverityEnum {
    CRITICAL("CRITICAL"),
    HIGH("HIGH"),
    MEDIUM("MEDIUM"),
    LOW("LOW");

    private String value;

    SeverityEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static SeverityEnum fromValue(String text) {
      for (SeverityEnum b : SeverityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("severity")
  private SeverityEnum severity = null;

  @JsonProperty("link")
  private String link = null;

  @JsonProperty("created_on")
  private OffsetDateTime createdOn = null;

  @JsonProperty("updated_on")
  private OffsetDateTime updatedOn = null;

  public ReportAnnotation externalId(String externalId) {
    this.externalId = externalId;
    return this;
  }

   /**
   * ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it&#x27;s generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
   * @return externalId
  **/
  @Schema(description = "ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.")
  public String getExternalId() {
    return externalId;
  }

  public void setExternalId(String externalId) {
    this.externalId = externalId;
  }

  public ReportAnnotation uuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

   /**
   * The UUID that can be used to identify the annotation.
   * @return uuid
  **/
  @Schema(description = "The UUID that can be used to identify the annotation.")
  public String getUuid() {
    return uuid;
  }

  public void setUuid(String uuid) {
    this.uuid = uuid;
  }

  public ReportAnnotation annotationType(AnnotationTypeEnum annotationType) {
    this.annotationType = annotationType;
    return this;
  }

   /**
   * The type of the report.
   * @return annotationType
  **/
  @Schema(description = "The type of the report.")
  public AnnotationTypeEnum getAnnotationType() {
    return annotationType;
  }

  public void setAnnotationType(AnnotationTypeEnum annotationType) {
    this.annotationType = annotationType;
  }

  public ReportAnnotation path(String path) {
    this.path = path;
    return this;
  }

   /**
   * The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
   * @return path
  **/
  @Schema(description = "The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.")
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }

  public ReportAnnotation line(Integer line) {
    this.line = line;
    return this;
  }

   /**
   * The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
   * minimum: 1
   * @return line
  **/
  @Schema(description = "The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.")
  public Integer getLine() {
    return line;
  }

  public void setLine(Integer line) {
    this.line = line;
  }

  public ReportAnnotation summary(String summary) {
    this.summary = summary;
    return this;
  }

   /**
   * The message to display to users.
   * @return summary
  **/
  @Schema(description = "The message to display to users.")
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }

  public ReportAnnotation details(String details) {
    this.details = details;
    return this;
  }

   /**
   * The details to show to users when clicking on the annotation.
   * @return details
  **/
  @Schema(description = "The details to show to users when clicking on the annotation.")
  public String getDetails() {
    return details;
  }

  public void setDetails(String details) {
    this.details = details;
  }

  public ReportAnnotation result(ResultEnum result) {
    this.result = result;
    return this;
  }

   /**
   * The state of the report. May be set to PENDING and later updated.
   * @return result
  **/
  @Schema(description = "The state of the report. May be set to PENDING and later updated.")
  public ResultEnum getResult() {
    return result;
  }

  public void setResult(ResultEnum result) {
    this.result = result;
  }

  public ReportAnnotation severity(SeverityEnum severity) {
    this.severity = severity;
    return this;
  }

   /**
   * The severity of the annotation.
   * @return severity
  **/
  @Schema(description = "The severity of the annotation.")
  public SeverityEnum getSeverity() {
    return severity;
  }

  public void setSeverity(SeverityEnum severity) {
    this.severity = severity;
  }

  public ReportAnnotation link(String link) {
    this.link = link;
    return this;
  }

   /**
   * A URL linking to the annotation in an external tool.
   * @return link
  **/
  @Schema(description = "A URL linking to the annotation in an external tool.")
  public String getLink() {
    return link;
  }

  public void setLink(String link) {
    this.link = link;
  }

  public ReportAnnotation createdOn(OffsetDateTime createdOn) {
    this.createdOn = createdOn;
    return this;
  }

   /**
   * The timestamp when the report was created.
   * @return createdOn
  **/
  @Schema(description = "The timestamp when the report was created.")
  public OffsetDateTime getCreatedOn() {
    return createdOn;
  }

  public void setCreatedOn(OffsetDateTime createdOn) {
    this.createdOn = createdOn;
  }

  public ReportAnnotation updatedOn(OffsetDateTime updatedOn) {
    this.updatedOn = updatedOn;
    return this;
  }

   /**
   * The timestamp when the report was updated.
   * @return updatedOn
  **/
  @Schema(description = "The timestamp when the report was updated.")
  public OffsetDateTime getUpdatedOn() {
    return updatedOn;
  }

  public void setUpdatedOn(OffsetDateTime updatedOn) {
    this.updatedOn = updatedOn;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReportAnnotation reportAnnotation = (ReportAnnotation) o;
    return Objects.equals(this.externalId, reportAnnotation.externalId) &&
        Objects.equals(this.uuid, reportAnnotation.uuid) &&
        Objects.equals(this.annotationType, reportAnnotation.annotationType) &&
        Objects.equals(this.path, reportAnnotation.path) &&
        Objects.equals(this.line, reportAnnotation.line) &&
        Objects.equals(this.summary, reportAnnotation.summary) &&
        Objects.equals(this.details, reportAnnotation.details) &&
        Objects.equals(this.result, reportAnnotation.result) &&
        Objects.equals(this.severity, reportAnnotation.severity) &&
        Objects.equals(this.link, reportAnnotation.link) &&
        Objects.equals(this.createdOn, reportAnnotation.createdOn) &&
        Objects.equals(this.updatedOn, reportAnnotation.updatedOn) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(externalId, uuid, annotationType, path, line, summary, details, result, severity, link, createdOn, updatedOn, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReportAnnotation {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    externalId: ").append(toIndentedString(externalId)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("    annotationType: ").append(toIndentedString(annotationType)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    line: ").append(toIndentedString(line)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    details: ").append(toIndentedString(details)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    link: ").append(toIndentedString(link)).append("\n");
    sb.append("    createdOn: ").append(toIndentedString(createdOn)).append("\n");
    sb.append("    updatedOn: ").append(toIndentedString(updatedOn)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
